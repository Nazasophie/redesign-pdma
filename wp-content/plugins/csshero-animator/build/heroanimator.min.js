var parallaxAnims, scrollAnims, availablePresets, bodyAnimationReq, _animateBelowTresholds = !1,
    tolerance = 1200;

function disableBodyLerp() {
    const e = document.getElementsByTagName("html")[0],
        t = document.body;
    e.removeAttribute("style"), t.removeAttribute("style"), cancelAnimationFrame(bodyAnimationReq)
}

function enanbleBodyLerp() {
    const e = document.getElementsByTagName("html")[0],
        t = document.body;
    let r, o = 0,
        i = 0,
        n = o;

    function a(e, t, r) {
        return (1 - r) * e + r * t
    }
    e.style.height = t.clientHeight + "px", t.style.width = "100%", t.style.position = "fixed", t.style.top = 0, t.style.left = 0, window.addEventListener("scroll", function() {
        r = window.pageXOffset, o = window.pageYOffset
    }), bodyAnimationReq = window.requestAnimationFrame(function e() {
        i = 0;
        n = a(n, o, .08);
        i = 0;
        t.style.transform = `translate(-${i}px, -${n}px)`;
        bodyAnimationReq = window.requestAnimationFrame(e)
    })
}

function returnDefaultUnitValue(e) {
    let t = "px";
    return -1 < (e = e.toLowerCase()).indexOf("rotate") && (t = "deg"), -1 < e.indexOf("skew") && (t = "deg"), "scale" === e && (t = "%"), t = "boxShadow" === e || -1 < e.indexOf("color") || "bgposition" === e || "bgsize" === e ? "" : t
}

function storeInlineStyles() {
    const e = document.querySelectorAll("*[style]");
    e.forEach(e => {
        var t = e.getAttribute("style");
        e.setAttribute("inlinestyle", t)
    })
}

function applyAllAnimations(e) {
    storeInlineStyles();
    var {
        data: e,
        customTimedAnimations: t,
        usedPresets: r,
        bodyLerp: o,
        animateBelowTresholds: i,
        tresholdTolerance: n,
        operations: a
    } = e, i = (_animateBelowTresholds = i, { ...e
    });
    if (n && !isNaN(n) && (tolerance = n), a) try {
        const s = new Function("data", a);
        s(i)
    } catch (e) {
        console.log(e)
    }
    parallaxAnims && cancelAnimationFrame(parallaxAnims), scrollAnims && cancelAnimationFrame(scrollAnims);
    e = makeFV(), availablePresets = r, applyParallaxAnims(i, e), applyScrollAnims(i), n = { ...t,
        ...r.timed
    };
    applyTimedStyles(i, n), o && (disableBodyLerp(), enanbleBodyLerp())
}

function colorToRGBA(e) {
    const t = document.createElement("div");
    t.style.backgroundColor = e, document.body.appendChild(t);
    let r = getComputedStyle(t).getPropertyValue("background-color");
    return t.remove(), -1 === r.indexOf("rgba") && (r += ",1"), r.match(/[\.\d]+/g).map(e => +e)
}

function mixTwoRGBA(r, o = 50) {
    let i = [];
    for (let t = 0; t < 4; t++) {
        let e = 3 == t ? e => e : Math.round;
        i[t] = e(r[0][t] + (r[1][t] - r[0][t]) * o / 100)
    }
    return `rgba(${i})`
}
document.addEventListener("DOMContentLoaded", () => {
    let e = !1;
    try {
        e = heroAnimator_saved_object
    } catch (e) {
        console.log(e)
    }
    e && applyAllAnimations(JSON.parse(e))
});
const mixColorsByPerc = (e, t, r) => {
        let o = !1;
        try {
            var i = mixTwoRGBA([colorToRGBA(t), colorToRGBA(r)], e);
            o = i
        } catch (e) {}
        return o
    },
    removeParameter = (e, t) => {
        t && t.getAttribute(e) && (t.removeAttribute(e), refreshStyles(t))
    },
    setParameter = (e, t, r) => {
        r && (r.setAttribute(e, t), refreshStyles(r))
    },
    refreshStyles = e => {
        var t;
        e && ((t = (e.getAttribute("inlinestyle") ? e.getAttribute("inlinestyle") + ";" : "") + (e.getAttribute("parallaxstyle") ? e.getAttribute("parallaxstyle") + ";" : "") + (e.getAttribute("scrollstyle") ? e.getAttribute("scrollstyle") + ";" : "")) ? e.setAttribute("style", t) : e.removeAttribute("style"))
    },
    getTransitionedScrollVal = (e, t, r, o, i) => {
        var n = e[t],
            e = e[t + 1];
        let a = o;
        return n && e && (t = n.val, o = e.val, n = 100 * (r - (r = n.pos)) / (e.pos - r), "width" === i && (e = (parseInt(o) - parseInt(t)) / 100 * n, r = parseInt(t) + e + "%", a = r), -1 < i.indexOf("color") && (a = mixColorsByPerc(n, t, o))), a
    },
    modeAppliesToCurrentScreenSize = e => {
        e = e ? .options ? .disabledOnMobile;
        return !(e && window.innerWidth < e)
    },
    applyScrollAnims = t => {
        const r = document.getElementById("scrollerIframe") ? document.getElementById("scrollerIframe").contentWindow : window,
            s = r["scrollY"];
        var o, i;
        for (o in t)
            if (t[o].scroll && modeAppliesToCurrentScreenSize(t[o].scroll)) {
                const a = [];
                for (var n in t[o].scroll.properties) {
                    const l = [];
                    for (let e in t[o].scroll.properties[n]) l.push({
                        pos: -1 < (i = e).indexOf("%") ? r.document.body.clientHeight / 100 * parseInt(i) : parseInt(i),
                        step: e,
                        val: t[o].scroll.properties[n][e]
                    });
                    const c = ((i, n) => {
                        let a = [];
                        return i.sort((e, t) => e.pos - t.pos), i.forEach((e, t) => {
                            var {
                                pos: e,
                                val: r
                            } = e, t = getTransitionedScrollVal(i, t, s, r, n);
                            let o = "custom-css" === n ? r + ";" : n + ":" + t + ";";
                            o = o.split(";;").join(";"), s >= e && a.push(o)
                        }), 0 !== a.length && a
                    })(l, n);
                    c && a.push(c.join(" "))
                }
                let e = [];
                try {
                    e = r.document.querySelectorAll(o)
                } catch (e) {}
                0 < a.length ? 0 < e.length && e.forEach(e => setParameter("scrollstyle", a.join(""), e)) : 0 < e.length && e.forEach(e => removeParameter("scrollstyle", e))
            }
        scrollAnims = requestAnimationFrame(() => applyScrollAnims(t))
    },
    deepCopy = e => JSON.parse(JSON.stringify(e)),
    getOffsetsWithoutTransforms = (e, t) => {
        let r = e,
            {
                offsetHeight: o,
                offsetWidth: i
            } = e,
            n = 0,
            a = 0;
        for (; a += r.offsetLeft, n += r.offsetTop, r = r.offsetParent;);
        return {
            left: a,
            width: i,
            height: o,
            top: n - t.pageYOffset
        }
    },
    mixArrayNumbers = (r, e, t) => {
        const o = [];
        let i = e.split(" "),
            n = t.split(" ");
        return i.forEach((e, t) => {
            e = parseInt(e), t = parseInt(n[t]), t = e + parseInt((t - e) / 100 * r);
            o.push(t)
        }), o
    },
    getPosition = (e, t) => {
        let r = "";
        var o;
        return e && (o = t["innerHeight"], o = o / 100, {
            top: e,
            height: t
        } = getOffsetsWithoutTransforms(e, t), e = parseInt(e + .5 * t), r = e / o), r
    },
    returnStepsArrayFromOb = e => {
        const t = [];
        for (var r in e) t.push(+r);
        return t.sort((e, t) => parseInt(e) - parseInt(t)), t
    },
    mixBoxShadow = (i, e, t) => {
        const n = [];
        let r = e.split(" "),
            a = t.split(" ");
        return r.forEach((e, t) => {
            var r = parseInt(e),
                o = parseInt(a[t]);
            isNaN(r) ? n.push(mixColorsByPerc(i, e, a[t])) : (e = r + parseInt((o - r) / 100 * i), n.push(e + "px"))
        }), n.join(" ")
    };

function isElementInViewport(e) {
    for (var t = e.offsetTop, r = e.offsetHeight; e.offsetParent;) t += (e = e.offsetParent).offsetTop;
    return t + -1 * tolerance < window.pageYOffset + window.innerHeight && t + r + 100 > window.pageYOffset
}

function generateParallaxStyles(f, b, y, g, h, v) {
    if (-1 < f.getAttribute("class").indexOf("demo") || _animateBelowTresholds || isElementInViewport(f)) {
        var A, x = document.getElementById("scrollerIframe") ? document.getElementById("scrollerIframe").contentWindow : window,
            w = h || getPosition(f, x);
        const N = deepCopy(b);
        for (A in N) {
            var S = returnStepsArrayFromOb(N[A]);
            N[A][-9999] = N[A][S[0]], N[A][9999] = N[A][S[S.length - 1]]
        }
        const q = e => {
            e = e.toString();
            const t = parseInt(e);
            e = e.replace(t.toString(), "");
            return {
                v: t,
                u: e
            }
        };
        var I, O, z;
        const L = (e, t) => (e = parseInt(e), v[y][t] = v[y][t] + (e - v[y][t]) * g, v[y][t]);
        let t = "",
            o = [],
            i = "",
            n = "",
            a = "",
            s = "",
            l = "",
            c = "",
            u = "",
            p = "",
            m = "",
            d = "",
            e = "",
            r = "";
        for (let r in N) {
            var B = returnStepsArrayFromOb(N[r]);
            for (let e = 0; e < B.length; e++) {
                var T = B[e],
                    P = N[r][T],
                    E = B[e + 1],
                    C = N[r][E] || !1;
                if (C && T < w && w <= E) {
                    var T = 100 * (w - T) / (E - T),
                        F = parseInt(T),
                        k = (k = C, O = F, z = void 0, {
                            v: (z = q(I = P).v) + (q(k).v - z) / 100 * O,
                            u: q(I).u
                        });
                    if ("opacity" === r) i = .01 * L(k.v, r);
                    else if ("width" === r) d = k.v + k.u;
                    else if ("backgroundColor" === r) n = mixColorsByPerc(F, P, C);
                    else if ("boxShadow" === r) p = mixBoxShadow(F, P, C);
                    else if ("fontSize" === r) t = L(k.v, r) + k.u;
                    else if ("blur" === r) l = L(k.v, r) + k.u;
                    else if ("custom-css" === r) w <= E && (s = C);
                    else if ("bgPosition" === r) {
                        c = mixArrayNumbers(F, P, C);
                        let t = [];
                        c && c.forEach(e => t.push(L(e, r) + "%")), c = t.join(" ")
                    } else if ("bgSize" === r) {
                        u = mixArrayNumbers(T, P, C);
                        let t = [];
                        u && u.forEach(e => t.push(L(e, r) + "%")), u = t.join(" ")
                    } else "textColor" === r ? a = mixColorsByPerc(F, P, C) : "letterSpacing" === r ? m = L(k.v, r) + k.u : o.push(r + "(" + L(k.v, r) + k.u + ")")
                }
            }
        }
        return d = d && "width:" + d + ";", m = m && "letter-spacing:" + m + ";", o.length && (o = "transform:" + o.join(" ") + ";"), !i && "0" !== i.toString() || (i = "opacity:" + i + ";"), n = n && "background-color:" + n + ";", a = a && "color:" + a + ";", l = l && "filter:blur(" + l + ");", c = c && "background-position:" + c + ";", u = u && "background-size:" + u + ";", t = t && "font-size:" + t + ";", p = p && "box-shadow:" + p + ";", e = e && "left:" + e + ";", r = r && "top:" + r + ";", o + i + n + a + l + c + u + t + s + p + m + d + e + r
    }
}
const applyParallaxAnims = (i, n) => {
        const e = document.getElementById("scrollerIframe") ? document.getElementById("scrollerIframe").contentWindow : window;
        let a = -1;
        for (let o in i) {
            const t = e.document.querySelectorAll(o);
            t.forEach(t => {
                var r = i ? .[o] ? .parallax ? .properties || i ? .[o] ? .parallax ? .presets;
                if (t && r && modeAppliesToCurrentScreenSize(i[o].parallax)) {
                    a++;
                    let e = i[o].parallax["lerp"];
                    e = e || 1;
                    r = {}, r = generateParallaxStyles(t, { ...i[o].parallax.properties,
                        ...r
                    }, a, e, !1, n);
                    r ? setParameter("parallaxstyle", r, t) : removeParameter("parallaxstyle", t)
                } else removeParameter("parallaxstyle", t)
            })
        }
        parallaxAnims = requestAnimationFrame(() => applyParallaxAnims(i, n))
    },
    applyTimedStyles = (t, e) => {
        let r = "",
            o = "";
        const i = document.head,
            n = [];
        for (var a in e) - 1 === n.indexOf(a) && (o += e[a], n.push(a));
        for (var s in t) {
            let e = "";
            var l = t ? .[s] ? .timed ? .options ? .trigger;
            if (l && "viewport" === l && (e = ".heroFXvisible"), t[s].timed && modeAppliesToCurrentScreenSize(t[s].timed)) {
                r += s + e + "{animation:";
                const b = [];
                for (var c of t[s].timed.properties) {
                    var {
                        animation: c,
                        options: u
                    } = c, {
                        duration: u,
                        easing: p,
                        delay: m,
                        repeat: d,
                        direction: f
                    } = u, p = timedDefaults.easing[p] || p;
                    b.push(c + " " + u + " " + p + " " + m + " " + d + " " + f)
                }
                r += b.join(",") + ";}"
            }
        }
        i && (removeTimedStyles(), i.insertAdjacentHTML("beforeend", `<style id="heroFXStyles">${o}${r}</style>`))
    },
    removeTimedStyles = () => {
        const e = document.getElementById("heroFXStyles");
        e && e.remove()
    };
var timedDefaults = {
    direction: {
        normal: "normal",
        reverse: "reverse",
        alternate: "alternate",
        "alternate-reverse": "alternate-reverse"
    },
    repeat: {
        "One time": 1,
        "2 times": 2,
        "3 times": 3,
        "5 times": 5,
        "10 times": 10,
        infinite: "infinite"
    },
    easing: {
        linear: "cubic-bezier(0,0,1,1)",
        ease: "cubic-bezier(0,.3,1,.3)",
        "ease-in": "cubic-bezier(0,.5,1,1)",
        "ease-in-out": "cubic-bezier(0,.5,1,.5)",
        easeOutCubic: "cubic-bezier(.215,.61,.355,1)",
        easeInOutCubic: "cubic-bezier(.645,.045,.355,1)",
        easeInCirc: "cubic-bezier(.6,.04,.98,.335)",
        easeOutCirc: "cubic-bezier(.075,.82,.165,1)",
        easeInOutCirc: "cubic-bezier(.785,.135,.15,.86)",
        easeInExpo: "cubic-bezier(.95,.05,.795,.035)",
        easeOutExpo: "cubic-bezier(.19,1,.22,1)",
        easeInOutExpo: "cubic-bezier(1,0,0,1)",
        easeInQuad: "cubic-bezier(.55,.085,.68,.53)",
        easeOutQuad: "cubic-bezier(.25,.46,.45,.94)",
        easeInOutQuad: "cubic-bezier(.455,.03,.515,.955)",
        easeInQuart: "cubic-bezier(.895,.03,.685,.22)",
        easeOutQuart: "cubic-bezier(.165,.84,.44,1)",
        easeInOutQuart: "cubic-bezier(.77,0,.175,1)",
        easeInQuint: "cubic-bezier(.755,.05,.855,.06)",
        easeOutQuint: "cubic-bezier(.23,1,.32,1)",
        easeInOutQuint: "cubic-bezier(.86,0,.07,1)",
        easeInSine: "cubic-bezier(.47,0,.745,.715)",
        easeOutSine: "cubic-bezier(.39,.575,.565,1)",
        easeInOutSine: "cubic-bezier(.445,.05,.55,.95)",
        easeInBack: "cubic-bezier(.6,-.28,.735,.045)",
        easeOutBack: "cubic-bezier(.175, .885,.32,1.275)",
        easeInOutBack: "cubic-bezier(.68,-.55,.265,1.55)"
    }
};

function makeFV() {
    var e = {
        translateY: 0,
        translateX: 0,
        rotateX: 0,
        rotateY: 0,
        rotateZ: 0,
        scale: 0,
        skewX: 0,
        opacity: 0,
        left: 0,
        skewY: 0,
        fontSize: 0,
        perspective: 0,
        letterSpacing: 0,
        bgPosition: 0,
        blur: 0,
        bgSize: 0,
        width: 0,
        top: 0
    };
    return [{ ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }, { ...e
    }]
}